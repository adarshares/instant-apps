{
  "anagrams": {
    "c++": "#include <boost/scoped_ptr.hpp>\n#include <iostream>\n#include <queue>\n \ntemplate<typename T>\nclass TreeNode {\npublic:\n  TreeNode(const T& n, TreeNode* left = NULL, TreeNode* right = NULL)\n    : mValue(n),\n      mLeft(left),\n      mRight(right) {}\n \n  T getValue() const {\n    return mValue;\n  }\n \n  TreeNode* left() const {\n    return mLeft.get();\n  }\n \n  TreeNode* right() const {\n    return mRight.get();\n  }\n \n  void preorderTraverse() const {\n    std::cout << \" \" << getValue();\n    if(mLeft)  { mLeft->preorderTraverse();  }\n    if(mRight) { mRight->preorderTraverse(); }\n  }\n \n  void inorderTraverse() const {\n    if(mLeft)  { mLeft->inorderTraverse();  }\n    std::cout << \" \" << getValue();\n    if(mRight) { mRight->inorderTraverse(); }\n  }\n \n  void postorderTraverse() const {\n    if(mLeft)  { mLeft->postorderTraverse();  }\n    if(mRight) { mRight->postorderTraverse(); }\n    std::cout << \" \" << getValue();\n  }\n \n  void levelorderTraverse() const {\n    std::queue<const TreeNode*> q;\n    q.push(this);\n \n    while(!q.empty()) {\n      const TreeNode* n = q.front();\n      q.pop();\n      std::cout << \" \" << n->getValue();\n \n      if(n->left())  { q.push(n->left());  }\n      if(n->right()) { q.push(n->right()); }\n    }\n  }\n \nprotected:\n  T mValue;\n  boost::scoped_ptr<TreeNode> mLeft;\n  boost::scoped_ptr<TreeNode> mRight;\n \nprivate:\n  TreeNode();\n};\n \nint main() {\n  TreeNode<int> root(1,\n    new TreeNode<int>(2,\n      new TreeNode<int>(4,\n        new TreeNode<int>(7)),\n      new TreeNode<int>(5)),\n    new TreeNode<int>(3,\n      new TreeNode<int>(6,\n        new TreeNode<int>(8),\n        new TreeNode<int>(9))));\n \n  std::cout << \"preorder:   \";\n  root.preorderTraverse();\n  std::cout << std::endl;\n \n  std::cout << \"inorder:    \";\n  root.inorderTraverse();\n  std::cout << std::endl;\n \n  std::cout << \"postorder:  \";\n  root.postorderTraverse();\n  std::cout << std::endl;\n \n  std::cout << \"level-order:\";\n  root.levelorderTraverse();\n  std::cout << std::endl;\n \n  return 0;\n}",
    "go": "package main\n \nimport (\n    \"bytes\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"sort\"\n)\n \nfunc main() {\n    r, err := http.Get(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    b, err := ioutil.ReadAll(r.Body)\n    r.Body.Close()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    var ma int\n    var bs byteSlice\n    m := make(map[string][][]byte)\n    for _, word := range bytes.Fields(b) {\n        bs = append(bs[:0], byteSlice(word)...)\n        sort.Sort(bs)\n        k := string(bs)\n        a := append(m[k], word)\n        if len(a) > ma {\n            ma = len(a)\n        }\n        m[k] = a\n    }\n    for _, a := range m {\n        if len(a) == ma {\n            fmt.Printf(\"%s\\n\", a)\n        }\n    }\n}\n \ntype byteSlice []byte\n \nfunc (b byteSlice) Len() int           { return len(b) }\nfunc (b byteSlice) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }\nfunc (b byteSlice) Less(i, j int) bool { return b[i] < b[j] }",
    "java": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n \npublic class WordsOfEqChars {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\");\n        InputStreamReader isr = new InputStreamReader(url.openStream());\n        BufferedReader reader = new BufferedReader(isr);\n \n        Map<String, Collection<String>> anagrams = new HashMap<String, Collection<String>>();\n        String word;\n        int count = 0;\n        while ((word = reader.readLine()) != null) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            if (!anagrams.containsKey(key))\n                anagrams.put(key, new ArrayList<String>());\n            anagrams.get(key).add(word);\n            count = Math.max(count, anagrams.get(key).size());\n        }\n \n        reader.close();\n \n        for (Collection<String> ana : anagrams.values())\n            if (ana.size() >= count)\n                System.out.println(ana);\n    }   \n}",
    "javascript": "var fs = require('fs');\nvar dictionary = fs.readFileSync('unixdict.txt', 'UTF-8').split('\\n');\n \n//group anagrams\nvar sortedDict = dictionary.reduce(function (acc, word) {\n  var sortedLetters = word.split('').sort().join('');\n  if (acc[sortedLetters] === undefined) { acc[sortedLetters] = []; }\n  acc[sortedLetters].push(word);\n  return acc;\n}, {});\n \n//sort list by frequency\nvar keysSortedByFrequency = Object.keys(sortedDict).sort(function (keyA, keyB) {\n  if (sortedDict[keyA].length < sortedDict[keyB].length) { return 1; }\n  if (sortedDict[keyA].length > sortedDict[keyB].length) { return -1; }\n  return 0;\n});\n \n//print first 10 anagrams by frequency\nkeysSortedByFrequency.slice(0, 10).forEach(function (key) {\n  console.log(sortedDict[key].join(' '));\n});"
  },
  "bfs": {
    "c++": "#include <boost/scoped_ptr.hpp>\n#include <iostream>\n#include <queue>\n \ntemplate<typename T>\nclass TreeNode {\npublic:\n  TreeNode(const T& n, TreeNode* left = NULL, TreeNode* right = NULL)\n    : mValue(n),\n      mLeft(left),\n      mRight(right) {}\n \n  T getValue() const {\n    return mValue;\n  }\n \n  TreeNode* left() const {\n    return mLeft.get();\n  }\n \n  TreeNode* right() const {\n    return mRight.get();\n  }\n \n  void preorderTraverse() const {\n    std::cout << \" \" << getValue();\n    if(mLeft)  { mLeft->preorderTraverse();  }\n    if(mRight) { mRight->preorderTraverse(); }\n  }\n \n  void inorderTraverse() const {\n    if(mLeft)  { mLeft->inorderTraverse();  }\n    std::cout << \" \" << getValue();\n    if(mRight) { mRight->inorderTraverse(); }\n  }\n \n  void postorderTraverse() const {\n    if(mLeft)  { mLeft->postorderTraverse();  }\n    if(mRight) { mRight->postorderTraverse(); }\n    std::cout << \" \" << getValue();\n  }\n \n  void levelorderTraverse() const {\n    std::queue<const TreeNode*> q;\n    q.push(this);\n \n    while(!q.empty()) {\n      const TreeNode* n = q.front();\n      q.pop();\n      std::cout << \" \" << n->getValue();\n \n      if(n->left())  { q.push(n->left());  }\n      if(n->right()) { q.push(n->right()); }\n    }\n  }\n \nprotected:\n  T mValue;\n  boost::scoped_ptr<TreeNode> mLeft;\n  boost::scoped_ptr<TreeNode> mRight;\n \nprivate:\n  TreeNode();\n};\n \nint main() {\n  TreeNode<int> root(1,\n    new TreeNode<int>(2,\n      new TreeNode<int>(4,\n        new TreeNode<int>(7)),\n      new TreeNode<int>(5)),\n    new TreeNode<int>(3,\n      new TreeNode<int>(6,\n        new TreeNode<int>(8),\n        new TreeNode<int>(9))));\n \n  std::cout << \"preorder:   \";\n  root.preorderTraverse();\n  std::cout << std::endl;\n \n  std::cout << \"inorder:    \";\n  root.inorderTraverse();\n  std::cout << std::endl;\n \n  std::cout << \"postorder:  \";\n  root.postorderTraverse();\n  std::cout << std::endl;\n \n  std::cout << \"level-order:\";\n  root.levelorderTraverse();\n  std::cout << std::endl;\n \n  return 0;\n}",
    "java": "public static boolean isPalindrome(String input) {\n\tfor (int i = 0, j = input.length() - 1; i < j; i++, j--) {\n\t\tchar startChar = input.charAt(i);\n\t\tchar endChar = input.charAt(j);\n \n\t\t// Handle surrogate pairs in UTF-16\n\t\tif (Character.isLowSurrogate(endChar)) {\n\t\t\tif (startChar != input.charAt(--j)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (input.charAt(++i) != endChar) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (startChar != endChar) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
    "javascript": "var isPal = str => str === str.split(\"\").reverse().join(\"\");"
  }
}
